# 바이브 코딩 실현 가능성 비판적 검토 (2026)

## 1. 요약 (Executive Summary)

**판정**: 기술적으로는 실현 가능하나, 운영상으로는 깨지기 쉬움 (Technically Feasible, but Operationally Fragile).

이 저장소에서 정의한 "바이브 코딩"은 "멀티 에이전트 시스템"의 기술적 혁신이라기보다는, 정교한 **프롬프트 엔지니어링 프레임워크**에 가깝습니다. 이는 LLM이 순차적으로 다양한 전문가 역할을 "연기(roleplay)"하는 능력을 활용합니다.

-   **장점**: "0에서 1"을 만드는 창조(그린필드 프로젝트)에 매우 탁월합니다. `active_spec.md` 패턴은 컨텍스트 표류(Context Drift) 문제를 효과적으로 해결합니다.
-   **단점**: 유지보수 단계에서 취약합니다. 사용자가 개입하지 않고 "연기"가 진행되도록 놔두는 사용자의 절제력에 크게 의존합니다. "자동 트리거"들은 실제 시스템 데몬이 아니라 희망 사항이 담긴 지침일 뿐입니다.

## 2. 아키텍처 비판

### "에이전트"의 환상 (The Agent Illusion)
`agents/*.md` 문서들은 `pm-orchestrator`, `architect` 같은 존재를 정의하고 있습니다.
-   **실체**: 이것들은 **시스템 지침(System Instructions)**입니다. 각 에이전트를 위한 별도의 프로세스나 컨테이너는 존재하지 않습니다.
-   **의미**: "전역 컨텍스트(Global Context)"가 공유됩니다. 만약 `vibe-implementer`가 엉망으로 코드를 짜면, `code-reviewer` (동일한 LLM 인스턴스)는 자신의 직전 기록에서 그 엉망인 코드를 보고, 방금 자기가 짰기 때문에 "괜찮다"고 환각(hallucinate)을 일으킬 수 있습니다.
-   **완화책**: `active_spec.md`가 "외부 초자아(External Super-Ego)" 역할을 하여, LLM이 자신의 휘발성 단기 기억 대신 정적 문서를 기준으로 작업을 검토하게 강제해야 합니다.

### "도구"의 한계 (The Tool Limitations)
에이전트들은 `Grep`, `Glob`, `Bash` 같은 도구를 쓴다고 명시되어 있습니다.
-   **실체**: 이것들은 메인 Claude 인스턴스가 사용하는 표준 도구들입니다.
-   **위험**: `planner` 에이전트가 `implementer`가 코드를 짜는 것을 시스템적으로 *실제로* 막을 수는 없습니다. "게이트키핑"은 순전히 의미론적(semantic)일 뿐입니다. 사용자가 "그냥 해"라고 하면 모든 문은 열립니다.

## 3. "동기화" 병목 - 치명적 결함 (The Sync Bottleneck)

제안된 워크플로우는 **"Active Context Files"** 전략에 의존합니다:
`Planner` -> `active_spec.md` 작성 -> `Implementer`가 `active_spec.md` 읽기 -> 코드 작성.

-   **마찰 (Friction)**: 작은 변경 사항마다 마크다운 명세서를 업데이트하는 것은 관료주의적으로 느껴집니다.
-   **표류 (Drift)**: 사용자가 "빠른 수정"을 위해 `active_spec.md` 업데이트를 건너뛰면, 파일은 **죽은 데이터(Stale Data)**가 됩니다.
-   **붕괴 (Collapse)**: `active_spec.md`가 낡은 상태가 되면, (그 파일을 신뢰하라고 지침 받은) 에이전트들은 옛날 명세에 기초해 환각 섞인 수정안을 내놓기 시작합니다. 시스템은 붕괴하고 평범한 채팅 세션으로 전락합니다.

## 4. "바이브" 검증 - 몰입 상태 (Verification of Vibe)

"바이브 코딩"은 AI가 세부 사항을 처리하는 동안의 몰입감(Flow state)을 약속합니다.

-   **성공 조건**: 사용자가 마이크로매니저가 아니라 **전략적 감독자(Strategic Director)**로서 행동해야 합니다. 사용자는 `git-guardian`이 분기를 만들고 `architect`가 선택하는 것을 신뢰해야 합니다.
-   **실패 조건**: 사용자가 끊임없이 "진짜 파일 확인했어?"라고 의심하며 확인하려 들면, 토큰 비용은 폭발하고 "바이브(속도)"는 "검증(편집증)"으로 인해 사라집니다.

## 5. 결론 및 제안

**가능한가?** 네.
**확장성 있는가?** `Active Sync` 프로토콜(분석의 옵션 C)을 엄격히 준수할 때만 그렇습니다.

**권장 조치**:
`active_spec.md` 워크플로우의 **"파일럿 테스트"**를 진행해 보십시오.
1.  엄격한 규칙 설정: **"유효한 `active_spec.md` 없이는 코드 구현 금지"**.
2.  이 "관료주의"가 "재-프롬프팅(Context Drift)"을 줄여 결과적으로 개발 속도를 높여주는지 검증하십시오.
